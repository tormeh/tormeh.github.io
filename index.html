<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <!-- Thanks to "Motherfucking Website" for teaching me how to write this -->
    
    <title>Fumurt</title>
</head>

<body>

<header>
        <h1>Fumurt - A Programming Language with Deterministic Multithreading: The ideas</h1>
        <aside></aside>
    </header>


<h2>Introduction</h2>
<p>Skip down to "The concepts" if you don't care about introductions. I would.</p>
<p>In spring 2015 I made my own programming language. Coming from a real-time/automation background I think I had a fairly rare (though not unique) approach to language design and I thought someone might get some use out of the ideas I came up with during development. Or at least some entertainment. I'm writing this in spring 2016, so I've definitely </p>
<p>Here I'll explain some of the ideas I came up with when writing my own language for my master thesis. It's preferable to reading the thesis report for most, I would imagine. The thesis report is riddled with academese and passive-voice, and as far as the code quality goes the code generator sucks ass. No, really, I was in a hurry and I'm not exaggerating. Anyway, the thesis with code and everything is available here if you want the full-fat or are just allergic to colloquial language: <a href=http://brage.bibsys.no/xmlui/handle/11250/2352463>http://brage.bibsys.no/xmlui/handle/11250/2352463</a></p>

<h3>Unintentional shortcomings</h3>
<p> I had one semester and I'm not all that smart or motivated so I didn't have time to do quite a lot. There are no data structures, user defined nor built-in, printing to terminal is the only IO and the standard math operators are replaced with functions that really suck to type. That wasn't intentional. Oh, and it lacks support for multi-file programs. And, you know, lots of other things we take for granted in languages but that weren't the main focus of my thesis. I'll be talking about top threads and underthreads. The underthreads are theoretical as well. </p>

<h3>Inspiration and worthy mentions</h3>
<p>The multithreading concept in this programming language belongs to the synchronous programming family and I therefore owe Esterel a little hat-tip</p>
<p>If you end up liking what I wrote, I'd suggest you check out <a href=http://www.ceu-lang.org/>Ceu</a>. It's got a lot more man-hours than this has and is the only synchronous programming language which is intended to be used by ordinary people.</p>

<h2>The concepts - let's get to it</h2>

<h3>Deterministic multithreading that feels like conventional multithreading</h3>
<p> Real-time loves multithreading. Real-time programmers have been doing it for far longer than we've had multicore CPU's. Why? Because it's architecturally neat to give each device in a product its own thread. In reality, these devices are physically independent and so it makes sense to make their logic independent as well. The One Big While-Loop is also a popular solution but it's getting outdated now of course. The trouble with giving each device/robot-arm/whathaveyou their own thread is synchronisation and determinism. Typically this is fixed with painstaking attention to the C/C++/Ada code's quality. Those that are willing to offer some performance on the altar to determinism have come up with an alternative solution: Synchronous programming. The most widely used implementation, Esterel, has threads that communicate with each other using signals and other unconventional stuff I don't remember. So I set out to come up with something more familiar that preserved the fundamental idea of synchronous programming: Time is discretized and all operations during a time step are computed from <em>memory as it was at the beginning of the time step</em>.</p>
<p>I did it using a notion of top threads and underthreads. Underthreads are your classic parallel list comprehensions and futures, as seen in Scala, for example. These are inherently deterministic and therefore unproblematic. But what we want is also some threads that operate from start to end of program execution, with their own areas of responsibility - the top threads. While underthreads do their work and hand the result to the thread that spawned them, top threads never stop. So top threads need a way to communicate with each other that's still deterministic. The solution I found is to divide execution into two phases which repeat indefinitely: A computation phase, in which execution is parallel, and a communication phase, which is sequential.</p>

<p></p>

<h3>A declaration where you can see all the <em>top</em> threads their shared variables</h3>
<p></p>

<h3>It's functions all the way down</h3>
<p></p>

<h3>Dependencies between functions are explicit</h3>
<p></p>

<h3>Function arguments are distinguished by name, not sequence</h3>
<p></p>

</body>
</html>
